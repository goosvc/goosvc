import os
import json
from dataclasses import dataclass
import dataclasses
from goosvc.core import common as common
from goosvc.core.branches import GoosvcBranches
from goosvc.core.projects import GoosvcProjects
from goosvc.core.exceptions import GoosvcException

DEFAULT_PATH_CACHE_SIZE = 10 # paths per owner
DEFAULT_NODE_CACHE_SIZE = 10 # nodes per owner


@dataclass
class GoosvcNode:
    type: str
    parent_id: str # branch_id or node_id ond add, parent node id after store
    author: str
    content: str
    node_id: str = None # ID of the node generated by the system
    timestamp: str = None # Timestamp of the node generated by the system
    version: int = 0 # Version of the node generated by the system
    transaction_id: str = None # ID of the transaction that created the node

class GoosvcNodes:
    def __init__(self, projects_dir: str, branches: GoosvcBranches, projects: GoosvcProjects):
        # base folder for all projects
        self.projects_dir = projects_dir
        self.branches = branches
        self.projects = projects
        # path cache by owner
        self.path_cache = {}
        self.path_cache_size = DEFAULT_PATH_CACHE_SIZE
        # node cache by owner
        self.node_cache = {}
        self.node_cache_size = DEFAULT_NODE_CACHE_SIZE
    
    # always returns the branch id and node id of the new node. 
    # a new branch is created automatically whenever the nodes parent is not a head node.
    # exception: if silent is true, no new branch is created. this allows to add multiple nodes before the new branch becomes visible (used by merge)
    def add_node(self, owner: str, project: str, node: GoosvcNode, silent: bool = False):
        node_id = common.get_id()
        node.node_id = node_id
        node.timestamp = common.get_timestamp()
        if not node.parent_id == None:

            # lock project for write. if lock fails, throw exception
            # lock is released after the write operation
            if not self.projects.lock_project(owner, project):
                raise GoosvcException("1003")

            # print("check if parent is a branch head")
            branch_head = self.branches.get_branch_head(owner, project, node.parent_id)
            if branch_head == None:
                # parent_id it is not a branch id: check if its a node which is head of a branch
                if self.is_node(owner, project, node.parent_id):
                    branch_id = self.branches.get_branch_of_node(owner, project, node.parent_id)
                    if branch_id != None:
                        # its a head node
                        branch_head = node.parent_id
                        node.parent_id = branch_id
            if not branch_head == None:
                # it is a branch: save node and update the branch head
                # print("it is a branch")
                branch_id = node.parent_id
                node.parent_id = branch_head
                # read parent node
                parent_node = self.get_node(owner, project, branch_head)
                # check if parent node is part of an ongoing transaction
                if parent_node.transaction_id != None and parent_node.type != "transaction_end":
                    # print("parent node is part of an ongoing transaction")
                    # new node must refer to the same transaction id as parent node
                    if parent_node.transaction_id != node.transaction_id:
                        # print("Error: transaction id does not match")
                        self.projects.release_project(owner, project)
                        raise GoosvcException("1026")
                    # new node must not start a new transaction
                    if node.type == "transaction_start":
                        # print("Error: node tries to start a new transaction within an ongoing transaction")
                        self.projects.release_project(owner, project)
                        raise GoosvcException("1026")
                    # all fine, use the same node version as parent node
                    node.version = parent_node.version
                else:
                    # print("parent node is not part of an ongoing transaction")
                    # transaction id in new node is only allowed to start a new transaction 
                    # because the parent node is not part of an ongoing transaction
                    if node.transaction_id != None and node.type != "transaction_start":
                        # print("Error: node tries continue or end a non existing transaction")
                        self.projects.release_project(owner, project)
                        raise GoosvcException("1027")
                    # all fine. either there is no transaction id or the node is a transaction start
                    node.version = parent_node.version + 1
                # write new node to file
                self.__write_node(owner, project, node)
                self.branches.update_branch_head(owner, project, branch_id, node.node_id)
                self.projects.release_project(owner, project)
                return branch_id, node_id
            elif self.is_node(owner, project, node.parent_id):
                # print("parent node is a node but node is not a head: save node and create branch")
                parent_node = self.get_node(owner, project, node.parent_id)
                # check if parent node within a transaction
                if parent_node.transaction_id != None and parent_node.type != "transaction_end":
                    # print("Error: parent node is within a transaction. branching refused")
                    self.projects.release_project(owner, project)
                    raise GoosvcException("1028")
                node.version = self.get_node(owner,project,node.parent_id).version + 1
                self.__write_node(owner, project, node)
                if silent:
                    branch_id = None
                else:
                    branch_id = self.branches.create_branch(owner, project, node.node_id)
                self.projects.release_project(owner, project)
                return branch_id, node_id
            # print("invalid parent")  
            self.projects.release_project(owner, project)
            raise GoosvcException("1029")

        # print("no parent: save node and create branch")
        # check if new node does not continue or end a transaction
        if node.transaction_id != None and node.type != "transaction_start":
            # print("Error: node tries to continue or end a non existing transaction")
            raise GoosvcException("1027")
        
        # Since this is the first node of the branch, one might think that no lock is needed
        # because no other thread can access the branch because id is not known.
        # But if the project was locked to run a backup, lock is needed.

        # lock project for write. if lock fails, throw exception
        # lock is released after the write operation
        if not self.projects.lock_project(owner, project):
            raise GoosvcException("1003")
        node.version = 1
        self.__write_node(owner, project, node)
        branch_id = self.branches.create_branch(owner, project, node.node_id)
        self.projects.release_project(owner, project)

        return branch_id, node_id
    
    def is_node(self, owner: str, project: str, node_id: str, type: str = None):
        node_file = self.__get_node_file(owner, project, node_id)
        # without type check
        if type == None:
            return os.path.exists(node_file)
        # with type check
        node = self.get_node(owner, project, node_id)
        if node == None:
            return False
        return node.type == type
    
    # returns a node by id or branch head if its a branch id
    def get_node(self, owner: str, project: str, id: str):
        if id == None:
            return None
        # check if node is in cache
        if owner in self.node_cache and id in self.node_cache[owner]:
            return self.node_cache[owner][id]
        # load node from file
        node_file = self.__get_node_file(owner, project, id)
        if not os.path.exists(node_file):
            # Node does not exist
            branch_head = self.branches.get_branch_head(owner, project, id)
            if branch_head == None:
                return None
            return self.get_node(owner, project, branch_head)
        with open(node_file, 'r') as f:
            node = GoosvcNode(**json.loads(f.read()))
        # save node in cache
        if not owner in self.node_cache:
            self.node_cache[owner] = {}
        self.node_cache[owner][id] = node
        # remove oldest cache entry if cache is full
        if len(self.node_cache[owner]) > self.node_cache_size:
            del self.node_cache[owner][list(self.node_cache[owner].keys())[0]]
        return node
    
    # returns the last node of a branch filtered by type
    def get_last_node(self, owner: str, project: str, branch_id: str, type: str):
        branch_head = self.branches.get_branch_head(owner, project, branch_id)
        if branch_head == None:
            return None
        node = self.get_node(owner, project, branch_head)
        if type == None:
            return node
        while node != None:
            if node.type == type:
                return node
            node = self.get_node(owner, project, node.parent_id)
    
    # returns the last node id of a branch filtered by type
    def get_last_node_id(self, owner: str, project: str, branch_id: str, type: str):
        return self.get_last_node(owner, project, branch_id, type).node_id
    
    # returns a list of nodes from id to the root filtered by type. 
    # id can be a node id or a branch id. for branch id the head node is used as start
    def get_path(self, owner: str, project: str, id: str, types: list[str] = [], root_id: str = None):
        current_node = self.get_node(owner, project, id)
        if current_node == None:
            return []

        start_node_id = current_node.node_id # save start node id to store result in cache
        read_from_cache = False # if true, read from cache. if false, read from file
        cache_node_id = None # cache entry in use
        cache_index = 0 # current index in cache entry
        path = [] # path to return
        unfiltered_path = [] # path to cache
        if not owner in self.path_cache:
            self.path_cache[owner] = {}

        current_node_id = start_node_id
        while current_node_id != root_id:
            unfiltered_path.append(current_node)
            if len(types) == 0 or current_node.type in types:
                path.append(current_node)
            
            if not read_from_cache and current_node_id in self.path_cache[owner]:
                # print("start reading from cache")
                read_from_cache = True
                cache_node_id = current_node_id
            if read_from_cache:
                cache_index += 1
                if cache_index >= len(self.path_cache[owner][cache_node_id]):
                    # print("cache end reached")
                    break
                # print("read from cache")
                if len(types) == 0 and root_id == None:
                    # read all nodes from cache at once
                    path.extend(self.path_cache[owner][cache_node_id][1:])
                    unfiltered_path.extend(self.path_cache[owner][cache_node_id][1:])
                    break
                else:
                    # continue reading node by node
                    current_node = self.path_cache[owner][cache_node_id][cache_index]
            else:
                # print("read from file")                    
                current_node = self.get_node(owner, project, current_node.parent_id)
            if current_node == None:
                break
            current_node_id = current_node.node_id
        
        # validate path (in case path was dropped from cache while reading)
        if len(unfiltered_path) > 0: # empty path is possible if root_id is same as start_node_id
            if root_id == None: 
                if not unfiltered_path[-1].version == 1 or not unfiltered_path[-1].parent_id == None:
                    print("path invalid")
                    return []
            else:
                if not unfiltered_path[-1].parent_id == root_id:
                    print("path invalid")
                    return []
        
        # add path to cache if root_id is None and its not already in cache
        if root_id == None and not start_node_id in self.path_cache:
            # print("add path to cache", start_node_id)
            # print("cache size", len(self.path_cache))
            self.path_cache[owner][start_node_id] = unfiltered_path
            # remove oldest cache entry if cache is full
            cached_ids = list(self.path_cache[owner].keys())
            if len(cached_ids) > self.path_cache_size:
                # print("remove oldest cache entry")
                del self.path_cache[owner][cached_ids[0]]


        return path
    
    # returns all nodes of a project
    def get_nodes(self, owner: str, project: str):
        project_dir = common.get_project_dir(self.projects_dir, owner, project)
        nodes_dir = os.path.join(project_dir, "nodes")
        nodes = []
        for node_file in os.listdir(nodes_dir):
            with open(os.path.join(nodes_dir, node_file), 'r') as f:
                nodes.append(GoosvcNode(**json.loads(f.read())))
        return nodes
    
    def __get_node_file(self, owner: str, project: str, node_id: str):
        project_dir = common.get_project_dir(self.projects_dir, owner, project)
        return os.path.join(project_dir, "nodes", node_id + ".json")
    
    def __write_node(self, owner: str, project: str, node: GoosvcNode):
        node_file = self.__get_node_file(owner, project, node.node_id)
        with open(node_file, 'w') as f:
            f.write(json.dumps(dataclasses.asdict(node)))
    


